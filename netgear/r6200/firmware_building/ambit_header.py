from checksum import LibAcosChecksum
from bowcaster.common import Logging
from bowcaster.common.support import pretty_string
from bowcaster.common.support import LittleEndian
from bowcaster.common.support import BigEndian
from bowcaster.development import SectionCreator
from bowcaster.development import OverflowBuffer
import struct
import re


class AmbitHeaderException(Exception):
    pass

class AmbitHeader(object):
    
    def __init__(self,firmware_bytes,version_string=None,logger=None):
        if not logger:
            logger=Logging()
        
        #Ambit header is big endian even on little endian systems.
        sc=SectionCreator(BigEndian)
        
        version_string_offset=0x09
        
        board_id="U12H192T00_NETGEAR"
        ambit_magic="*#$^"
        header_len=0x3A #typical header length seen in real examples.
        checksum_offset=36
        
        #length of entire firmware, including TRX header, kernel, filesystem.
        image_length=len(firmware_bytes)
        image_length_offset=24
        
        #We don't use a separate kernel, so it's size is 0
        kernel_size_offset=28
        kernel_size=0
        
        #the checksum of the firmware image is found in two fields in
        #the header.
        image_checksum_1_offset=16
        image_checksum_2_offset=32
        
        checksum=LibAcosChecksum(firmware_bytes,len(firmware_bytes))
        image_checksum=checksum.checksum
        logger.LOG_INFO("Image checksum: 0x%08x" % image_checksum)
        
        #No need to checksum the kernel since we don't use a separate kernel.
        kernel_checksum=0
        kernel_checksum_offset=20
        
        #Put the magic ambit signature at the start of the header.
        sc.string_section(0,ambit_magic) #must be null terminated but
                                        #null byte overlaps with next section
        #Ambit header length.
        sc.gadget_section(4,header_len,"Length of ambit header.")
        
        if version_string:
            version_string=self._calc_version_string(version_string)
            #This gets transformed to a version string per the format:
            #"V"
            sc.string_section(version_string_offset,version_string,"Firmware version string.")
        
        #Length of firmware image, not counting Ambit header.
        sc.gadget_section(image_length_offset,
                            image_length,description="Number of bytes in the firmware, not counting this header.")
        
        #Size of kernel, 0 since there's no kernel separate from the firmware image.
        sc.gadget_section(kernel_size_offset,kernel_size,
                            description="second length field. this is 0 in firmware obtained from vendor.")
        
        #Board ID. This is device specific.                    
        sc.string_section(40,board_id,description="Board ID string in firmware header.")
        
        #Put the image checksum at two different offsets.
        sc.gadget_section(image_checksum_1_offset,image_checksum,description="First image checksum.")
        sc.gadget_section(image_checksum_2_offset,image_checksum,description="Second image checksum.")
        
        #build a pre-checksum Ambit header so that we can calculate it's checksum.
        pre_checksum_header=OverflowBuffer(BigEndian,header_len,sc.section_list)
        
        #Calculate the Ambit header's checksum
        #the 4-byte field for the checksum will be zeroed out at checksum_offset
        #before the calculation is performed.
        checksum=LibAcosChecksum(str(pre_checksum_header),header_len,checksum_offset)
        
        header_checksum=checksum.checksum
        logger.LOG_INFO("Header checksum: 0x%08x" % header_checksum)
        
        #Add the Ambit header checksum
        sc.gadget_section(checksum_offset,header_checksum)
        
        
        buf=OverflowBuffer(BigEndian,header_len,sc.section_list)
        
        self.buf=buf

    def __str__(self):
        return str(self.buf)
    
    def _calc_version_string(self,version_string):
        version_regex="V(\d+?)\.(\d+?)\.(\d+?)\.(\d+?)_(\d+?)\.(\d+?)\.(\d+?)"
        print version_string
        parts=re.match(version_regex,version_string).groups()
        if len(parts) != 7:
            raise AmbitHeaderException("Invalid version string: %s" % version_string)
        version_string=""
        for part in parts:
            version_string+=struct.pack("B",int(part))
        
        return version_string
        